---
title: data race과 deadlock
category: [cpp]
tag: [cpp]
toc: true
toc_label: 목차
toc_sticky: true
---
# data race란?

---
하나의 데이터를 가지고 경쟁을 벌이는 일.
## data race가 발생하는 경우
* 다음 세 경우를 만족할때 data race가 발생한다.
> 1. 한 프로세스에서 두 개 이상의 스레드가 하나의 메모리에 접근할때.
> 2. 그 중 하나 이상의 스레드에서 해당 메모리에 쓰기 작업을 할 때.
> 3. 그 스레드가 메모리를 독점적으로 관리하기 위한 락을 걸지 않았을 때.

## 현상
메모리 접근 순서가 때에 따라 다르기 때문에, 운이 좋으면 원하는 결과를 얻을 수도 있지만 
운이 나쁜 경우에는 심각한 버그를 일으킬수 있다.   

![data_race](/assets/datarace_deadlock/data_race.png)   
위 코드에서 for_each함수가 병렬적으로 실행되는데, 이 경우 v.push_back()을 두번 수행한다.      
첫번째 push_back()을 위해 메모리에 접근하고 i*2+1을 추가하고 저장하기 직전에   
두번째 push_back()을 위해 메모리에 접근한다면   
아직 비어있는 벡터 v를 불러오게 될 것이다.  
<br> 
그렇다면 함수가 다 끝나고 난 뒤 길이가 2인 벡터가 남아야하는데 v는 길이가 1인 벡터일 것이다. 
병렬실행에 의해 예기치 못한 문제가 생기는것을 data race 라고 한다.


# deadlock란?
---
스레드가 진행되지 않고 멈춰버리는 일
## deadlock이 발생하는 경우
> 1. 이미 락을 걸고있는 스레드가 다른 락을 요청할때.
> 2. 새로운 락 요청이 동시에 발생할때.
> 3. 두개 이상의 스레드가 꼬리에 꼬리를 물고 락을 걸어버렸을 때.

## 현상
얼음땡을 하는데 도망가는 두명이 다 얼음을 외쳐서 결국 아무도 움직일수가 없는 상태와 비슷하다.
사실 lock을 어떻게 거는지 잘 모르겠어서 코드상으로 설명할수가 없다. ㅎ.ㅎ   
deadlock이 걸릴 여지가 있는 코드지만 운이 좋아서 프로그램이 잘 돌아간 경우에 potential deadlock이라고 하고   
운이 나빠서 deadlock이 걸린 경우는 actual deadlock
# 출처
---
data race와 deadlock 설명 : 오라클 홈페이지에 있는 내용을 재해석   
data race 예제 : cppreference